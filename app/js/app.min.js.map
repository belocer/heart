{"version":3,"sources":["Box3D.js","app.js"],"names":["Box3D","obj","_classCallCheck","this","varDebounce","сountdownAnim","card","document","querySelector","card__container","tiltAngle","addEventListener","mainAnimate","bind","circle__shadow","el","item","removeAttribute","e","_this","clearTimeout","rect","target","getBoundingClientRect","layerX","offset_y","offsetY","layerY","width","x","y","elementDirectionalShift","setTimeout","clearTagStyle","offsetX","signX","arguments","length","undefined","signY","transform","concat","offset_x","window","wrap_anime_div","wrap_anime_div1","createElement","div","classList","add","i","appendChild","anime","targets","translateX","random","translateY","scale","easing","delay","stagger","animateDiv","header","querySelectorAll","startAnimateText","forEach","style","strokeDasharray","animate","fill","duration","clearInterval","idInterval","setInterval"],"mappings":"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","file":"app.min.js","sourcesContent":["\"use strict\";","class Box3D {\r\n    constructor(obj) {\r\n        this.varDebounce = 0; // ТаймАут срабатывания всей анимации\r\n        this.сountdownAnim = 0; // ТаймАут срабатывания анимации завершения\r\n        this.card = document.querySelector(obj.card); // Анимируемый блок\r\n        this.card__container = document.querySelector(obj.card__container); // Блок контейнер\r\n        this.tiltAngle = obj.tiltAngle || 10; // угол отклонения в градусах\r\n        this.card__container.addEventListener('mousemove', this.mainAnimate.bind(this));\r\n        this.circle__shadow = document.querySelector(obj.circle__shadow); // Внутренняя тень\r\n    }\r\n\r\n    clearTagStyle(el) {\r\n        el.forEach(item => item.removeAttribute('style'));\r\n    }\r\n\r\n    mainAnimate(e) {\r\n        clearTimeout(this.varDebounce);\r\n        clearTimeout(this.сountdownAnim);\r\n        this.varDebounce = setTimeout(() => {\r\n            let rect = e.target.getBoundingClientRect();\r\n            let offset_x = e.offsetX || e.layerX\r\n            let offset_y = e.offsetY || e.layerY\r\n            let x = 100 * offset_x / rect.width;\r\n            let y = 100 * offset_y / rect.height;\r\n\r\n            if (x < 50 && y < 50) { // Левый верхний угол\r\n                this.elementDirectionalShift(this.tiltAngle, -this.tiltAngle);\r\n            } else if (x > 50 && y < 50) { // Правый верхний угол\r\n                this.elementDirectionalShift(this.tiltAngle, this.tiltAngle, '-', '');\r\n            } else if (x < 50 && y > 50) { // Левый нижний угол\r\n                this.elementDirectionalShift(-this.tiltAngle, -this.tiltAngle, '', '-');\r\n            } else if (x > 50 && y > 50) { // Правый нижний угол\r\n                this.elementDirectionalShift(-this.tiltAngle, this.tiltAngle, '-', '-');\r\n            }\r\n        }, 1);\r\n\r\n        this.сountdownAnim = setTimeout(() => {\r\n            this.clearTagStyle([this.card]);\r\n            this.clearTagStyle([this.circle__shadow]);\r\n        }, 3000)\r\n    }\r\n\r\n    elementDirectionalShift(x, y, signX = '', signY = '') {\r\n        this.card.style.transform = `perspective(1200px) rotateX(${x}deg) rotateY(${y}deg) translateZ(0)`;\r\n        this.circle__shadow.style.boxShadow = `${signX}7px ${signY}7px 20px 10px #0009, inset 0 0 1px 2px rgba(146, 82, 82, 0.56)`;\r\n    }\r\n}\r\n\r\nwindow.addEventListener('load', () => {\r\n    let obg_card = {\r\n        card: '.loader', // Анимируемый блок\r\n        card__container: '.container', // Блок контейнер\r\n        tiltAngle: 35, // угол отклонения в градусах\r\n        circle__shadow: '.circle__shadow',\r\n    };\r\n    new Box3D(obg_card);\r\n\r\n    /* Anime.js*/\r\n    let wrap_anime_div = document.querySelector('.wrap_anime_div');\r\n    let wrap_anime_div1 = document.querySelector('.wrap_anime_div1');\r\n\r\n    for (let i = 0; i <= 50; i++) {\r\n        const div = document.createElement('div');\r\n        div.classList.add('block');\r\n        wrap_anime_div.appendChild(div);\r\n    }\r\n\r\n    for (let i = 0; i <= 50; i++) {\r\n        const div = document.createElement('div');\r\n        div.classList.add('block');\r\n        wrap_anime_div1.appendChild(div);\r\n    }\r\n\r\n    function animateDiv() {\r\n        anime({\r\n            targets: '.block',\r\n            translateX: function () {\r\n                return anime.random(-1100, 1100);\r\n            },\r\n            translateY: function () {\r\n                return anime.random(-500, 500);\r\n            },\r\n            scale: function () {\r\n                return anime.random(1, 5);\r\n            },\r\n            easing: 'linear',\r\n            duration: 5000,\r\n            delay: anime.stagger(10),\r\n            complete: animateDiv,\r\n        })\r\n    }\r\n\r\n    animateDiv();\r\n\r\n    /* Анимация заголовка */\r\n    let header = document.querySelectorAll('.header__svg path');\r\n    startAnimateText()\r\n    function startAnimateText() {\r\n        let i = 0\r\n        let idInterval = setInterval(() => {\r\n            if (i < 1600) {\r\n                i > 1000 ? i += 10 : i += 3;\r\n                header.forEach(item => item.style.strokeDasharray = `${i}px`);\r\n            } else {\r\n                header.forEach(item => {\r\n                    item.style.strokeDasharray = `3000px`\r\n                    item.animate([{fill: 'rgba(250,250,250, 1)'},{fill: 'rgba(0,0,0, 0)'}],\r\n                        {\r\n                            duration: 2000,\r\n                            easing: 'ease-in-out',\r\n                            fill: 'forwards'\r\n                        });\r\n                });\r\n                clearInterval(idInterval);\r\n                backAnimateText()\r\n            }\r\n        }, 50)\r\n    }\r\n\r\n    function backAnimateText() {\r\n        let i = 1600\r\n        let idInterval = setInterval(() => {\r\n            if (i > 1600) {\r\n                i < 1000 ? i -= 3 : i -= 10;\r\n                header.forEach(item => item.style.strokeDasharray = `${i}px`);\r\n            } else {\r\n                header.forEach(item => item.style.strokeDasharray = `1600px`);\r\n                clearInterval(idInterval);\r\n                startAnimateText();\r\n            }\r\n        }, 50);\r\n    }\r\n});\r\n"]}